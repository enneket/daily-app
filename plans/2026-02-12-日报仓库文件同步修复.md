# 日报仓库文件同步问题修复方案

## 问题描述

当前桌面应用在初始化日报仓库时存在严重问题：

1. **文件版本不同步**：桌面应用仓库的文件已更新（添加了安全检查、默认值等），但已初始化的日报仓库仍使用旧版本文件
2. **无更新机制**：`checkRepoInitialized()` 只检查 `config.ts` 是否存在，不检查文件版本，导致旧文件永远不会被更新
3. **用户体验差**：用户需要手动删除文件才能触发重新初始化

**当前错误**：日报仓库构建失败，报错 `Cannot read properties of undefined (reading 'day')`，因为使用的是旧版本的 `calendar.md` 等文件。

## 技术方案

### 方案：版本文件 + 强制更新机制

在日报仓库根目录创建 `.daily-version.json` 文件来追踪版本：

```json
{
  "version": "1.1.0",
  "updatedAt": "2026-02-12T10:00:00Z",
  "files": {
    "site/.vitepress/config.ts": "1.1.0",
    "site/.vitepress/reports-index.data.ts": "1.1.0",
    "site/.vitepress/stats.data.ts": "1.1.0",
    "site/.vitepress/reports-index.json": "1.1.0",
    "site/.vitepress/stats.json": "1.1.0",
    "site/index.md": "1.1.0",
    "site/calendar.md": "1.1.0",
    "site/archive.md": "1.1.0",
    "site/stats.md": "1.1.0",
    "site/latest.md": "1.1.0",
    "scripts/generate-index.js": "1.1.0",
    "package.json": "1.1.0",
    ".gitignore": "1.0.0",
    ".github/workflows/deploy-site.yml": "1.0.0"
  }
}
```

### 实现步骤

#### 第 1 步：定义当前版本
在 `src/main/github-service.ts` 中定义：

```typescript
private readonly CURRENT_VERSION = '1.1.0';
private readonly FILE_VERSIONS: Record<string, string> = {
  'site/.vitepress/config.ts': '1.1.0',
  'site/.vitepress/reports-index.data.ts': '1.1.0',
  'site/.vitepress/stats.data.ts': '1.1.0',
  'site/.vitepress/reports-index.json': '1.1.0',
  'site/.vitepress/stats.json': '1.1.0',
  'site/index.md': '1.1.0',
  'site/calendar.md': '1.1.0',
  'site/archive.md': '1.1.0',
  'site/stats.md': '1.1.0',
  'site/latest.md': '1.1.0',
  'scripts/generate-index.js': '1.1.0',
  'package.json': '1.1.0',
  '.gitignore': '1.0.0',
  '.github/workflows/deploy-site.yml': '1.0.0'
};
```

#### 第 2 步：实现版本检查
```typescript
private async checkVersion(): Promise<{ needsUpdate: boolean; outdatedFiles: string[] }> {
  try {
    const { data } = await this.octokit.repos.getContent({
      owner: this.config.repoOwner,
      repo: this.config.repoName,
      path: '.daily-version.json',
      ref: this.config.branch,
    });
    
    if ('content' in data) {
      const versionInfo = JSON.parse(Buffer.from(data.content, 'base64').toString());
      
      // 比较版本
      if (versionInfo.version !== this.CURRENT_VERSION) {
        return { needsUpdate: true, outdatedFiles: Object.keys(this.FILE_VERSIONS) };
      }
      
      // 检查单个文件版本
      const outdatedFiles = [];
      for (const [file, version] of Object.entries(this.FILE_VERSIONS)) {
        if (versionInfo.files[file] !== version) {
          outdatedFiles.push(file);
        }
      }
      
      return { needsUpdate: outdatedFiles.length > 0, outdatedFiles };
    }
  } catch (error) {
    // 没有版本文件，需要完整更新
    return { needsUpdate: true, outdatedFiles: Object.keys(this.FILE_VERSIONS) };
  }
  
  return { needsUpdate: false, outdatedFiles: [] };
}
```

#### 第 3 步：修改初始化逻辑
```typescript
async testConnectionAndInitialize(): Promise<{ 
  initialized: boolean; 
  skipped: boolean; 
  updated: boolean;
  updatedFiles: string[];
}> {
  await this.testConnection();
  
  const { needsUpdate, outdatedFiles } = await this.checkVersion();
  
  if (needsUpdate) {
    await this.updateRepoFiles(outdatedFiles);
    return { 
      initialized: true, 
      skipped: false, 
      updated: true,
      updatedFiles: outdatedFiles
    };
  }
  
  return { 
    initialized: false, 
    skipped: true, 
    updated: false,
    updatedFiles: []
  };
}
```

#### 第 4 步：实现文件更新
```typescript
private async updateRepoFiles(filesToUpdate: string[]): Promise<void> {
  console.log(`需要更新 ${filesToUpdate.length} 个文件...`);
  
  // 准备文件内容
  const files: Array<{ path: string; content: string }> = [];
  
  // ... 复制文件逻辑（与 initializeRepo 类似）
  
  // 添加版本文件
  const versionInfo = {
    version: this.CURRENT_VERSION,
    updatedAt: new Date().toISOString(),
    files: this.FILE_VERSIONS
  };
  files.push({ 
    path: '.daily-version.json', 
    content: JSON.stringify(versionInfo, null, 2) 
  });
  
  // 批量更新文件
  for (const file of files) {
    if (filesToUpdate.includes(file.path) || file.path === '.daily-version.json') {
      await this.createOrUpdateFile(file.path, file.content);
    }
  }
}
```

#### 第 5 步：优化用户反馈
在 `Settings.tsx` 中：

```typescript
const result = await window.electron.saveConfig(config);

if (result.updated) {
  setMessage({
    type: 'success',
    text: `配置已保存！已更新 ${result.updatedFiles.length} 个文件到最新版本。`
  });
} else if (result.skipped) {
  setMessage({
    type: 'success',
    text: '配置已保存！仓库已是最新版本，无需更新。'
  });
} else {
  setMessage({
    type: 'success',
    text: '配置已保存，仓库初始化完成！'
  });
}
```

## 实施计划

### 阶段 1：核心功能（已完成 ✅）
- [x] 在 `github-service.ts` 中添加版本常量
- [x] 实现 `checkVersion()` 方法
- [x] 修改 `testConnectionAndInitialize()` 返回更详细的状态
- [x] 实现 `updateRepoFiles()` 方法
- [x] 在初始化时添加版本文件

### 阶段 2：用户界面优化（已完成 ✅）
- [x] 更新 `Settings.tsx` 显示更新详情
- [x] 在主进程中传递更新结果
- [ ] 添加"强制重新初始化"按钮（可选，暂不实施）

### 阶段 3：测试验证（待用户测试）
- [ ] 测试全新仓库初始化
- [ ] 测试旧仓库自动更新
- [ ] 测试部分文件过期场景
- [ ] 验证日报仓库构建成功

## 测试场景

1. **全新仓库**
   - 预期：完整初始化，创建 `.daily-version.json`
   - 验证：所有文件都存在且版本正确

2. **旧仓库（无版本文件）**
   - 预期：完整更新所有文件，创建版本文件
   - 验证：构建成功，不再报错

3. **已更新仓库**
   - 预期：跳过更新，显示"已是最新版本"
   - 验证：不产生新的 commit

4. **部分文件过期**
   - 预期：只更新过期的文件
   - 验证：只有指定文件被更新

## 成功标准

- [ ] 用户保存配置后，日报仓库自动更新到最新版本
- [ ] 日报仓库构建成功，不再报 `Cannot read properties of undefined` 错误
- [ ] 用户界面显示清晰的更新反馈
- [ ] 不影响用户已有的日报内容（`docs/**/*.md`）

## 风险和缓解

### 风险 1：更新失败导致仓库不可用
**缓解**：
- 更新前检查网络连接
- 失败时回滚或提示用户手动修复
- 提供"强制重新初始化"选项

### 风险 2：频繁更新打扰用户
**缓解**：
- 只在保存配置时检查更新
- 版本相同时跳过更新
- 显示更新内容让用户知情

### 风险 3：版本文件冲突
**缓解**：
- 使用 `createOrUpdateFileContents` API 自动处理冲突
- 版本文件由应用完全管理，不建议用户修改

## 后续优化

1. **版本更新日志**：在文档中维护版本更新说明
2. **手动更新按钮**：在设置界面添加"检查更新"按钮
3. **更新通知**：检测到新版本时提示用户
4. **备份机制**：重要更新前自动创建备份分支

## 相关文件

- `src/main/github-service.ts` - 核心逻辑
- `src/main/main.ts` - IPC 处理
- `src/renderer/components/Settings.tsx` - 用户界面
- 所有 `site/` 和 `scripts/` 下的文件 - 需要同步的文件

## 参考

- 当前版本：1.1.0（修复了数据加载器的安全检查问题）
- 上一版本：1.0.0（初始版本，存在 undefined 错误）
